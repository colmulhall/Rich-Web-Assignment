{"version":3,"file":"\\packages\\accounts-base.js","sources":["accounts-base/accounts_common.js","accounts-base/accounts_server.js","accounts-base/url_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,iD;AACA,uC;AACA,8E;AACA,6E;AACA,0D;AACA,mD;AACA,0D;AACA,qD;AACA,gF;AACA,S;AACA,sC;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,uD;AACA,sE;AACA,mC;AACA,mC;AACA,yE;AACA,gB;AACA,E;AACA,qC;AACA,yE;AACA,6E;AACA,gF;AACA,2E;AACA,+B;AACA,wB;AACA,0D;AACA,+D;AACA,+E;AACA,sD;AACA,8E;AACA,6E;AACA,G;;AAEA,yB;AACA,2E;AACA,8E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;;AAEA,6E;AACA,4C;AACA,sB;AACA,oC;AACA,E;;AAEA,uE;AACA,kE;AACA,qD;AACA,E;AACA,2E;AACA,gE;AACA,c;;AAEA,uF;AACA,yE;AACA,wD;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;AAEA,kC;AACA,oD;AACA,+D;AACA,E;;AAEA,6C;AACA,2E;AACA,gC;AACA,qE;AACA,E;;AAEA,8C;AACA,gD;AACA,4D;AACA,uC;AACA,qC;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;AC3HA,G;AACA,gB;AACA,G;;AAEA,6B;AACA,sE;AACA,kE;AACA,oE;AACA,gE;AACA,kE;AACA,mE;AACA,kE;AACA,mE;AACA,oB;AACA,uD;AACA,yB;AACA,gH;AACA,kC;AACA,E;;AAEA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;AAEA,G;AACA,kB;AACA,G;;AAEA,8D;AACA,E;AACA,uE;AACA,uE;AACA,uC;AACA,mE;AACA,gF;AACA,8E;AACA,6E;AACA,W;AACA,kD;AACA,E;AACA,mD;AACA,8B;AACA,E;;AAEA,mC;AACA,mB;;;AAGA,oE;AACA,sE;AACA,0D;AACA,8C;AACA,kD;AACA,mC;AACA,kC;AACA,6B;AACA,oB;AACA,G;;AAEA,wE;AACA,E;;;AAGA,mE;AACA,8B;AACA,gB;AACA,2B;AACA,iE;AACA,+E;AACA,qB;AACA,4B;AACA,6E;AACA,wC;AACA,2B;AACA,8C;AACA,0B;AACA,gC;AACA,wC;AACA,K;AACA,kB;AACA,I;;AAEA,sB;AACA,sC;AACA,8B;AACA,6B;AACA,2C;AACA,yB;AACA,I;;AAEA,+E;AACA,0E;AACA,4E;AACA,0C;AACA,I;AACA,+D;AACA,mC;AACA,oB;AACA,kD;AACA,e;AACA,2C;AACA,O;AACA,O;AACA,e;AACA,iE;AACA,0E;AACA,+E;AACA,6E;AACA,c;AACA,oD;AACA,2D;AACA,+B;AACA,wC;AACA,e;AACA,wD;AACA,yD;AACA,U;AACA,0D;AACA,S;AACA,qC;AACA,gF;AACA,oC;AACA,0C;AACA,sD;AACA,mD;AACA,0E;AACA,6E;AACA,mB;AACA,c;AACA,8B;AACA,8D;AACA,Q;AACA,Y;AACA,gD;AACA,K;AACA,G;AACA,G;;AAEA,G;AACA,oB;AACA,G;AACA,mD;;AAEA,mC;AACA,iD;AACA,sB;AACA,qB;;AAEA,gC;AACA,mC;AACA,0D;AACA,K;;AAEA,c;AACA,0E;AACA,2B;AACA,G;;AAEA,yE;AACA,0C;AACA,K;;AAEA,2D;AACA,iC;AACA,iF;;AAEA,U;AACA,0B;AACA,+B;AACA,gB;AACA,I;AACA,G;;AAEA,+D;AACA,E;AACA,mD;AACA,gD;AACA,E;;AAEA,sE;AACA,sD;AACA,sD;AACA,+B;AACA,Y;AACA,4D;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,oB;AACA,G;;AAEA,wB;;AAEA,2E;AACA,gC;AACA,E;AACA,2D;AACA,qE;AACA,sE;AACA,4B;AACA,gF;AACA,6C;;AAEA,0E;AACA,qE;AACA,+E;AACA,G;;AAEA,sC;AACA,6C;AACA,+C;;;AAGA,+E;AACA,2B;AACA,4C;AACA,U;AACA,uE;AACA,uE;AACA,K;AACA,O;AACA,Y;AACA,sC;AACA,c;AACA,6C;AACA,6C;AACA,S;AACA,O;AACA,K;AACA,sB;AACA,0E;AACA,oB;AACA,E;;AAEA,6C;AACA,0D;AACA,yD;AACA,4B;AACA,8C;AACA,+B;AACA,G;AACA,E;;AAEA,sD;AACA,oE;;AAEA,G;AACA,qB;AACA,G;;AAEA,4B;AACA,yC;AACA,uB;AACA,uD;AACA,M;AACA,4B;AACA,E;;AAEA,4E;AACA,oC;AACA,sD;AACA,sB;AACA,mC;AACA,c;AACA,E;;AAEA,8B;AACA,mD;AACA,wD;AACA,8B;AACA,mE;AACA,4C;AACA,I;AACA,oE;AACA,iD;AACA,mE;AACA,iE;AACA,kE;AACA,iE;AACA,iB;AACA,mE;;AAEA,kB;AACA,mC;AACA,6D;AACA,sC;AACA,uE;AACA,+C;AACA,mD;AACA,0D;AACA,Q;AACA,wD;AACA,G;;AAEA,e;AACA,yB;AACA,+C;;AAEA,2E;AACA,yE;AACA,iE;AACA,yC;AACA,sD;AACA,U;AACA,oD;AACA,G;;AAEA,gD;AACA,wB;AACA,4D;AACA,K;;AAEA,O;AACA,8C;AACA,e;AACA,sC;AACA,yE;AACA,yC;AACA,0E;AACA,wB;AACA,mD;AACA,2D;AACA,4C;AACA,8D;AACA,yE;AACA,Y;AACA,G;;AAEA,gB;AACA,E;;AAEA,8B;AACA,4C;AACA,kC;AACA,E;;AAEA,oD;AACA,+D;AACA,+D;AACA,gC;AACA,gD;AACA,E;;AAEA,6E;AACA,qB;AACA,wC;AACA,+D;AACA,mB;AACA,8C;AACA,0B;AACA,oE;AACA,E;;AAEA,sE;AACA,0C;AACA,+D;AACA,c;AACA,gB;;AAEA,0B;AACA,gC;AACA,uD;AACA,4C;AACA,O;AACA,yC;AACA,iD;AACA,2D;AACA,6D;AACA,O;AACA,G;;AAEA,kB;AACA,gB;;AAEA,yB;AACA,kE;AACA,M;AACA,qE;AACA,G;;AAEA,G;AACA,yB;AACA,G;;AAEA,oE;AACA,E;AACA,0D;AACA,iE;AACA,iE;AACA,mE;AACA,2E;AACA,uB;AACA,mE;AACA,gC;AACA,E;AACA,0D;AACA,sC;AACA,mC;;AAEA,6D;AACA,oB;AACA,8E;AACA,uB;AACA,gC;AACA,oB;AACA,sE;;AAEA,0D;AACA,oB;AACA,uD;;AAEA,yD;AACA,wE;AACA,wE;AACA,qE;AACA,4E;AACA,6E;AACA,sE;AACA,4D;AACA,8B;AACA,sD;AACA,oE;AACA,U;AACA,4C;AACA,G;;AAEA,4C;;AAEA,a;AACA,6E;AACA,yE;AACA,6D;AACA,mE;AACA,0B;AACA,6D;AACA,sB;AACA,8C;AACA,8D;AACA,O;;AAEA,6E;AACA,2B;AACA,wB;AACA,e;AACA,sB;AACA,8D;AACA,Y;AACA,gC;AACA,mB;AACA,gE;AACA,M;AACA,U;AACA,6E;AACA,qB;AACA,0B;AACA,6C;AACA,sC;AACA,iD;AACA,G;AACA,E;;;AAGA,G;AACA,mB;AACA,G;;AAEA,mD;AACA,iC;AACA,oB;AACA,6B;AACA,yB;AACA,sD;AACA,U;AACA,gB;AACA,G;AACA,oD;;AAEA,iE;AACA,wD;AACA,qE;AACA,iE;AACA,kE;AACA,yB;AACA,kD;AACA,qC;AACA,E;;AAEA,6D;AACA,gE;AACA,8C;AACA,E;AACA,6B;AACA,8E;AACA,qF;AACA,gD;AACA,4C;AACA,0D;AACA,0C;AACA,sD;AACA,E;;AAEA,0B;AACA,+D;AACA,0B;AACA,8B;AACA,2D;AACA,4C;AACA,qD;AACA,0B;AACA,U;AACA,M;;AAEA,6C;AACA,wB;AACA,iC;AACA,6B;AACA,qE;AACA,c;AACA,oB;AACA,O;AACA,wD;;AAEA,gF;AACA,8E;AACA,6E;AACA,+E;AACA,gE;AACA,6C;AACA,mB;AACA,sB;AACA,6C;AACA,U;AACA,sB;;AAEA,+B;AACA,iB;AACA,iE;AACA,wD;AACA,K;AACA,C;;AAEA,oE;AACA,gE;AACA,6E;AACA,2E;;AAEA,oE;AACA,wD;AACA,gB;AACA,+C;AACA,6D;AACA,0E;AACA,yE;AACA,wB;AACA,2E;AACA,wE;AACA,0B;AACA,wB;AACA,2E;AACA,qD;AACA,K;AACA,gF;AACA,wF;AACA,wD;AACA,G;AACA,G;;;AAGA,G;AACA,sC;AACA,G;;AAEA,oB;AACA,oE;AACA,kB;AACA,qD;AACA,iC;AACA,4B;AACA,mB;;AAEA,iE;AACA,sE;AACA,0B;AACA,uD;AACA,mB;;AAEA,gB;AACA,I;AACA,wC;AACA,G;;AAEA,4B;AACA,8D;AACA,oE;AACA,8D;AACA,kD;AACA,6E;AACA,gB;AACA,oE;AACA,yC;AACA,4B;AACA,6E;;AAEA,G;AACA,qC;AACA,G;;AAEA,2D;AACA,uB;AACA,iC;AACA,e;AACA,qD;AACA,gD;AACA,Q;AACA,iB;AACA,qD;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,4B;AACA,6E;AACA,2E;AACA,gF;AACA,gF;AACA,0E;AACA,Y;AACA,iC;AACA,mD;AACA,M;AACA,4C;AACA,K;AACA,iC;AACA,0E;AACA,K;AACA,G;;AAEA,G;AACA,6B;AACA,G;;AAEA,gD;AACA,uE;AACA,uB;AACA,M;AACA,E;;AAEA,oE;AACA,wC;AACA,2B;AACA,sD;AACA,sD;AACA,6E;AACA,8E;AACA,6D;AACA,gE;AACA,K;AACA,sC;AACA,I;AACA,+B;AACA,oD;AACA,oE;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC7pBA,oD;;AAEA,mB;;AAEA,gD;AACA,yD;AACA,E;;AAEA,8C;AACA,uD;AACA,E;;AAEA,gD;AACA,yD;AACA,E","sourcesContent":["Accounts = {};\r\n\r\n// Currently this is read directly by packages like accounts-password\r\n// and accounts-ui-unstyled.\r\nAccounts._options = {};\r\n\r\n// how long (in days) until a login token expires\r\nvar DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\r\n// Clients don't try to auto-login with a token that is going to expire within\r\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\r\n// Tries to avoid abrupt disconnects from expiring tokens.\r\nvar MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\r\n// how often (in milliseconds) we check for expired tokens\r\nEXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\r\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\r\n// called\r\nCONNECTION_CLOSE_DELAY_MS = 10 * 1000;\r\n\r\n// Set up config for the accounts system. Call this on both the client\r\n// and the server.\r\n//\r\n// XXX we should add some enforcement that this is called on both the\r\n// client and the server. Otherwise, a user can\r\n// 'forbidClientAccountCreation' only on the client and while it looks\r\n// like their app is secure, the server will still accept createUser\r\n// calls. https://github.com/meteor/meteor/issues/828\r\n//\r\n// @param options {Object} an object with fields:\r\n// - sendVerificationEmail {Boolean}\r\n//     Send email address verification emails to new users created from\r\n//     client signups.\r\n// - forbidClientAccountCreation {Boolean}\r\n//     Do not allow clients to create accounts directly.\r\n// - restrictCreationByEmailDomain {Function or String}\r\n//     Require created users to have an email matching the function or\r\n//     having the string as domain.\r\n// - loginExpirationInDays {Number}\r\n//     Number of days since login until a user is logged out (login token\r\n//     expires).\r\n//\r\nAccounts.config = function(options) {\r\n  // We don't want users to accidentally only call Accounts.config on the\r\n  // client, where some of the options will have partial effects (eg removing\r\n  // the \"create account\" button from accounts-ui if forbidClientAccountCreation\r\n  // is set, or redirecting Google login to a specific-domain page) without\r\n  // having their full effects.\r\n  if (Meteor.isServer) {\r\n    __meteor_runtime_config__.accountsConfigCalled = true;\r\n  } else if (!__meteor_runtime_config__.accountsConfigCalled) {\r\n    // XXX would be nice to \"crash\" the client and replace the UI with an error\r\n    // message, but there's no trivial way to do this.\r\n    Meteor._debug(\"Accounts.config was called on the client but not on the \" +\r\n                  \"server; some configuration options may not take effect.\");\r\n  }\r\n\r\n  // validate option keys\r\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\",\r\n                    \"restrictCreationByEmailDomain\", \"loginExpirationInDays\"];\r\n  _.each(_.keys(options), function (key) {\r\n    if (!_.contains(VALID_KEYS, key)) {\r\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\r\n    }\r\n  });\r\n\r\n  // set values in Accounts._options\r\n  _.each(VALID_KEYS, function (key) {\r\n    if (key in options) {\r\n      if (key in Accounts._options) {\r\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\r\n      } else {\r\n        Accounts._options[key] = options[key];\r\n      }\r\n    }\r\n  });\r\n\r\n  // If the user set loginExpirationInDays to null, then we need to clear the\r\n  // timer that periodically expires tokens.\r\n  if (Meteor.isServer)\r\n    maybeStopExpireTokensInterval();\r\n};\r\n\r\n// Users table. Don't use the normal autopublish, since we want to hide\r\n// some fields. Code to autopublish this is in accounts_server.js.\r\n// XXX Allow users to configure this collection name.\r\n//\r\nMeteor.users = new Meteor.Collection(\"users\", {_preventAutopublish: true});\r\n// There is an allow call in accounts_server that restricts this\r\n// collection.\r\n\r\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\r\nAccounts.loginServiceConfiguration = ServiceConfiguration.configurations;\r\nAccounts.ConfigError = ServiceConfiguration.ConfigError;\r\n\r\n// Thrown when the user cancels the login process (eg, closes an oauth\r\n// popup, declines retina scan, etc)\r\nAccounts.LoginCancelledError = function(description) {\r\n  this.message = description;\r\n};\r\n\r\n// This is used to transmit specific subclass errors over the wire. We should\r\n// come up with a more generic way to do this (eg, with some sort of symbolic\r\n// error code rather than a number).\r\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\r\nAccounts.LoginCancelledError.prototype = new Error();\r\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\r\n\r\ngetTokenLifetimeMs = function () {\r\n  return (Accounts._options.loginExpirationInDays ||\r\n          DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\r\n};\r\n\r\nAccounts._tokenExpiration = function (when) {\r\n  // We pass when through the Date constructor for backwards compatibility;\r\n  // `when` used to be a number.\r\n  return new Date((new Date(when)).getTime() + getTokenLifetimeMs());\r\n};\r\n\r\nAccounts._tokenExpiresSoon = function (when) {\r\n  var minLifetimeMs = .1 * getTokenLifetimeMs();\r\n  var minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\r\n  if (minLifetimeMs > minLifetimeCapMs)\r\n    minLifetimeMs = minLifetimeCapMs;\r\n  return new Date() > (new Date(when) - minLifetimeMs);\r\n};\r\n","///\r\n/// CURRENT USER\r\n///\r\n\r\nMeteor.userId = function () {\r\n  // This function only works if called inside a method. In theory, it\r\n  // could also be called from publish statements, since they also\r\n  // have a userId associated with them. However, given that publish\r\n  // functions aren't reactive, using any of the infomation from\r\n  // Meteor.user() in a publish function will always use the value\r\n  // from when the function first runs. This is likely not what the\r\n  // user expects. The way to make this work in a publish is to do\r\n  // Meteor.find(this.userId()).observe and recompute when the user\r\n  // record changes.\r\n  var currentInvocation = DDP._CurrentInvocation.get();\r\n  if (!currentInvocation)\r\n    throw new Error(\"Meteor.userId can only be invoked in method calls. Use this.userId in publish functions.\");\r\n  return currentInvocation.userId;\r\n};\r\n\r\nMeteor.user = function () {\r\n  var userId = Meteor.userId();\r\n  if (!userId)\r\n    return null;\r\n  return Meteor.users.findOne(userId);\r\n};\r\n\r\n///\r\n/// LOGIN HANDLERS\r\n///\r\n\r\n// The main entry point for auth packages to hook in to login.\r\n//\r\n// @param handler {Function} A function that receives an options object\r\n// (as passed as an argument to the `login` method) and returns one of:\r\n// - `undefined`, meaning don't handle;\r\n// - {id: userId, token: *, tokenExpires: *}, if the user logged in\r\n//   successfully. tokenExpires is optional and intends to provide a hint to the\r\n//   client as to when the token will expire. If not provided, the client will\r\n//   call Accounts._tokenExpiration, passing it the date that it received the\r\n//   token.\r\n// - throw an error, if the user failed to log in.\r\n//\r\nAccounts.registerLoginHandler = function(handler) {\r\n  loginHandlers.push(handler);\r\n};\r\n\r\n// list of all registered handlers.\r\nloginHandlers = [];\r\n\r\n\r\n// Try all of the registered login handlers until one of them doesn'\r\n// return `undefined`, meaning it handled this call to `login`. Return\r\n// that return value, which ought to be a {id/token} pair.\r\nvar tryAllLoginHandlers = function (options) {\r\n  for (var i = 0; i < loginHandlers.length; ++i) {\r\n    var handler = loginHandlers[i];\r\n    var result = handler(options);\r\n    if (result !== undefined)\r\n      return result;\r\n  }\r\n\r\n  throw new Meteor.Error(400, \"Unrecognized options for login request\");\r\n};\r\n\r\n\r\n// Actual methods for login and logout. This is the entry point for\r\n// clients to actually log in.\r\nMeteor.methods({\r\n  // @returns {Object|null}\r\n  //   If successful, returns {token: reconnectToken, id: userId}\r\n  //   If unsuccessful (for example, if the user closed the oauth login popup),\r\n  //     returns null\r\n  login: function(options) {\r\n    // Login handlers should really also check whatever field they look at in\r\n    // options, but we don't enforce it.\r\n    check(options, Object);\r\n    var result = tryAllLoginHandlers(options);\r\n    if (result !== null) {\r\n      this.setUserId(result.id);\r\n      this._setLoginToken(result.token);\r\n    }\r\n    return result;\r\n  },\r\n\r\n  logout: function() {\r\n    var token = this._getLoginToken();\r\n    this._setLoginToken(null);\r\n    if (token && this.userId)\r\n      removeLoginToken(this.userId, token);\r\n    this.setUserId(null);\r\n  },\r\n\r\n  // Delete all the current user's tokens and close all open connections logged\r\n  // in as this user. Returns a fresh new login token that this client can\r\n  // use. Tests set Accounts._noConnectionCloseDelayForTest to delete tokens\r\n  // immediately instead of using a delay.\r\n  //\r\n  // @returns {Object} Object with token and tokenExpires keys.\r\n  logoutOtherClients: function () {\r\n    var self = this;\r\n    var user = Meteor.users.findOne(self.userId, {\r\n      fields: {\r\n        \"services.resume.loginTokens\": true\r\n      }\r\n    });\r\n    if (user) {\r\n      // Save the current tokens in the database to be deleted in\r\n      // CONNECTION_CLOSE_DELAY_MS ms. This gives other connections in the\r\n      // caller's browser time to find the fresh token in localStorage. We save\r\n      // the tokens in the database in case we crash before actually deleting\r\n      // them.\r\n      var tokens = user.services.resume.loginTokens;\r\n      var newToken = Accounts._generateStampedLoginToken();\r\n      var userId = self.userId;\r\n      Meteor.users.update(self.userId, {\r\n        $set: {\r\n          \"services.resume.loginTokensToDelete\": tokens,\r\n          \"services.resume.haveLoginTokensToDelete\": true\r\n        },\r\n        $push: { \"services.resume.loginTokens\": newToken }\r\n      });\r\n      Meteor.setTimeout(function () {\r\n        // The observe on Meteor.users will take care of closing the connections\r\n        // associated with `tokens`.\r\n        deleteSavedTokens(userId, tokens);\r\n      }, Accounts._noConnectionCloseDelayForTest ? 0 :\r\n                        CONNECTION_CLOSE_DELAY_MS);\r\n      // We do not set the login token on this connection, but instead the\r\n      // observe closes the connection and the client will reconnect with the\r\n      // new token.\r\n      return {\r\n        token: newToken.token,\r\n        tokenExpires: Accounts._tokenExpiration(newToken.when)\r\n      };\r\n    } else {\r\n      throw new Error(\"You are not logged in.\");\r\n    }\r\n  }\r\n});\r\n\r\n///\r\n/// RECONNECT TOKENS\r\n///\r\n/// support reconnecting using a meteor login token\r\n\r\n// Login handler for resume tokens.\r\nAccounts.registerLoginHandler(function(options) {\r\n  if (!options.resume)\r\n    return undefined;\r\n\r\n  check(options.resume, String);\r\n  var user = Meteor.users.findOne({\r\n    \"services.resume.loginTokens.token\": \"\"+options.resume\r\n  });\r\n\r\n  if (!user) {\r\n    throw new Meteor.Error(403, \"You've been logged out by the server. \" +\r\n    \"Please login again.\");\r\n  }\r\n\r\n  var token = _.find(user.services.resume.loginTokens, function (token) {\r\n    return token.token === options.resume;\r\n  });\r\n\r\n  var tokenExpires = Accounts._tokenExpiration(token.when);\r\n  if (new Date() >= tokenExpires)\r\n    throw new Meteor.Error(403, \"Your session has expired. Please login again.\");\r\n\r\n  return {\r\n    token: options.resume,\r\n    tokenExpires: tokenExpires,\r\n    id: user._id\r\n  };\r\n});\r\n\r\n// Semi-public. Used by other login methods to generate tokens.\r\n//\r\nAccounts._generateStampedLoginToken = function () {\r\n  return {token: Random.id(), when: (new Date)};\r\n};\r\n\r\n// Deletes the given loginToken from the database. This will cause all\r\n// connections associated with the token to be closed.\r\nvar removeLoginToken = function (userId, loginToken) {\r\n  Meteor.users.update(userId, {\r\n    $pull: {\r\n      \"services.resume.loginTokens\": { \"token\": loginToken }\r\n    }\r\n  });\r\n};\r\n\r\n///\r\n/// TOKEN EXPIRATION\r\n///\r\n\r\nvar expireTokenInterval;\r\n\r\n// Deletes expired tokens from the database and closes all open connections\r\n// associated with these tokens.\r\n//\r\n// Exported for tests. Also, the arguments are only used by\r\n// tests. oldestValidDate is simulate expiring tokens without waiting\r\n// for them to actually expire. userId is used by tests to only expire\r\n// tokens for the test user.\r\nvar expireTokens = Accounts._expireTokens = function (oldestValidDate, userId) {\r\n  var tokenLifetimeMs = getTokenLifetimeMs();\r\n\r\n  // when calling from a test with extra arguments, you must specify both!\r\n  if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\r\n    throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\r\n  }\r\n\r\n  oldestValidDate = oldestValidDate ||\r\n    (new Date(new Date() - tokenLifetimeMs));\r\n  var userFilter = userId ? {_id: userId} : {};\r\n\r\n\r\n  // Backwards compatible with older versions of meteor that stored login token\r\n  // timestamps as numbers.\r\n  Meteor.users.update(_.extend(userFilter, {\r\n    $or: [\r\n      { \"services.resume.loginTokens.when\": { $lt: oldestValidDate } },\r\n      { \"services.resume.loginTokens.when\": { $lt: +oldestValidDate } }\r\n    ]\r\n  }), {\r\n    $pull: {\r\n      \"services.resume.loginTokens\": {\r\n        $or: [\r\n          { when: { $lt: oldestValidDate } },\r\n          { when: { $lt: +oldestValidDate } }\r\n        ]\r\n      }\r\n    }\r\n  }, { multi: true });\r\n  // The observe on Meteor.users will take care of closing connections for\r\n  // expired tokens.\r\n};\r\n\r\nmaybeStopExpireTokensInterval = function () {\r\n  if (_.has(Accounts._options, \"loginExpirationInDays\") &&\r\n      Accounts._options.loginExpirationInDays === null &&\r\n      expireTokenInterval) {\r\n    Meteor.clearInterval(expireTokenInterval);\r\n    expireTokenInterval = null;\r\n  }\r\n};\r\n\r\nexpireTokenInterval = Meteor.setInterval(expireTokens,\r\n                                         EXPIRE_TOKENS_INTERVAL_MS);\r\n\r\n///\r\n/// CREATE USER HOOKS\r\n///\r\n\r\nvar onCreateUserHook = null;\r\nAccounts.onCreateUser = function (func) {\r\n  if (onCreateUserHook)\r\n    throw new Error(\"Can only call onCreateUser once\");\r\n  else\r\n    onCreateUserHook = func;\r\n};\r\n\r\n// XXX see comment on Accounts.createUser in passwords_server about adding a\r\n// second \"server options\" argument.\r\nvar defaultCreateUserHook = function (options, user) {\r\n  if (options.profile)\r\n    user.profile = options.profile;\r\n  return user;\r\n};\r\n\r\n// Called by accounts-password\r\nAccounts.insertUserDoc = function (options, user) {\r\n  // - clone user document, to protect from modification\r\n  // - add createdAt timestamp\r\n  // - prepare an _id, so that you can modify other collections (eg\r\n  // create a first task for every new user)\r\n  //\r\n  // XXX If the onCreateUser or validateNewUser hooks fail, we might\r\n  // end up having modified some other collection\r\n  // inappropriately. The solution is probably to have onCreateUser\r\n  // accept two callbacks - one that gets called before inserting\r\n  // the user document (in which you can modify its contents), and\r\n  // one that gets called after (in which you should change other\r\n  // collections)\r\n  user = _.extend({createdAt: new Date(), _id: Random.id()}, user);\r\n\r\n  var result = {};\r\n  if (options.generateLoginToken) {\r\n    var stampedToken = Accounts._generateStampedLoginToken();\r\n    result.token = stampedToken.token;\r\n    result.tokenExpires = Accounts._tokenExpiration(stampedToken.when);\r\n    Meteor._ensure(user, 'services', 'resume');\r\n    if (_.has(user.services.resume, 'loginTokens'))\r\n      user.services.resume.loginTokens.push(stampedToken);\r\n    else\r\n      user.services.resume.loginTokens = [stampedToken];\r\n  }\r\n\r\n  var fullUser;\r\n  if (onCreateUserHook) {\r\n    fullUser = onCreateUserHook(options, user);\r\n\r\n    // This is *not* part of the API. We need this because we can't isolate\r\n    // the global server environment between tests, meaning we can't test\r\n    // both having a create user hook set and not having one set.\r\n    if (fullUser === 'TEST DEFAULT HOOK')\r\n      fullUser = defaultCreateUserHook(options, user);\r\n  } else {\r\n    fullUser = defaultCreateUserHook(options, user);\r\n  }\r\n\r\n  _.each(validateNewUserHooks, function (hook) {\r\n    if (!hook(fullUser))\r\n      throw new Meteor.Error(403, \"User validation failed\");\r\n  });\r\n\r\n  try {\r\n    result.id = Meteor.users.insert(fullUser);\r\n  } catch (e) {\r\n    // XXX string parsing sucks, maybe\r\n    // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\r\n    if (e.name !== 'MongoError') throw e;\r\n    var match = e.err.match(/^E11000 duplicate key error index: ([^ ]+)/);\r\n    if (!match) throw e;\r\n    if (match[1].indexOf('$emails.address') !== -1)\r\n      throw new Meteor.Error(403, \"Email already exists.\");\r\n    if (match[1].indexOf('username') !== -1)\r\n      throw new Meteor.Error(403, \"Username already exists.\");\r\n    // XXX better error reporting for services.facebook.id duplicate, etc\r\n    throw e;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nvar validateNewUserHooks = [];\r\nAccounts.validateNewUser = function (func) {\r\n  validateNewUserHooks.push(func);\r\n};\r\n\r\n// XXX Find a better place for this utility function\r\n// Like Perl's quotemeta: quotes all regexp metacharacters. See\r\n//   https://github.com/substack/quotemeta/blob/master/index.js\r\nvar quotemeta = function (str) {\r\n    return String(str).replace(/(\\W)/g, '\\\\$1');\r\n};\r\n\r\n// Helper function: returns false if email does not match company domain from\r\n// the configuration.\r\nvar testEmailDomain = function (email) {\r\n  var domain = Accounts._options.restrictCreationByEmailDomain;\r\n  return !domain ||\r\n    (_.isFunction(domain) && domain(email)) ||\r\n    (_.isString(domain) &&\r\n      (new RegExp('@' + quotemeta(domain) + '$', 'i')).test(email));\r\n};\r\n\r\n// Validate new user's email or Google/Facebook/GitHub account's email\r\nAccounts.validateNewUser(function (user) {\r\n  var domain = Accounts._options.restrictCreationByEmailDomain;\r\n  if (!domain)\r\n    return true;\r\n\r\n  var emailIsGood = false;\r\n  if (!_.isEmpty(user.emails)) {\r\n    emailIsGood = _.any(user.emails, function (email) {\r\n      return testEmailDomain(email.address);\r\n    });\r\n  } else if (!_.isEmpty(user.services)) {\r\n    // Find any email of any service and check it\r\n    emailIsGood = _.any(user.services, function (service) {\r\n      return service.email && testEmailDomain(service.email);\r\n    });\r\n  }\r\n\r\n  if (emailIsGood)\r\n    return true;\r\n\r\n  if (_.isString(domain))\r\n    throw new Meteor.Error(403, \"@\" + domain + \" email required\");\r\n  else\r\n    throw new Meteor.Error(403, \"Email doesn't match the criteria.\");\r\n});\r\n\r\n///\r\n/// MANAGING USER OBJECTS\r\n///\r\n\r\n// Updates or creates a user after we authenticate with a 3rd party.\r\n//\r\n// @param serviceName {String} Service name (eg, twitter).\r\n// @param serviceData {Object} Data to store in the user's record\r\n//        under services[serviceName]. Must include an \"id\" field\r\n//        which is a unique identifier for the user in the service.\r\n// @param options {Object, optional} Other options to pass to insertUserDoc\r\n//        (eg, profile)\r\n// @returns {Object} Object with token and id keys, like the result\r\n//        of the \"login\" method.\r\n//\r\nAccounts.updateOrCreateUserFromExternalService = function(\r\n  serviceName, serviceData, options) {\r\n  options = _.clone(options || {});\r\n\r\n  if (serviceName === \"password\" || serviceName === \"resume\")\r\n    throw new Error(\r\n      \"Can't use updateOrCreateUserFromExternalService with internal service \"\r\n        + serviceName);\r\n  if (!_.has(serviceData, 'id'))\r\n    throw new Error(\r\n      \"Service data for service \" + serviceName + \" must include id\");\r\n\r\n  // Look for a user with the appropriate service user id.\r\n  var selector = {};\r\n  var serviceIdKey = \"services.\" + serviceName + \".id\";\r\n\r\n  // XXX Temporary special case for Twitter. (Issue #629)\r\n  //   The serviceData.id will be a string representation of an integer.\r\n  //   We want it to match either a stored string or int representation.\r\n  //   This is to cater to earlier versions of Meteor storing twitter\r\n  //   user IDs in number form, and recent versions storing them as strings.\r\n  //   This can be removed once migration technology is in place, and twitter\r\n  //   users stored with integer IDs have been migrated to string IDs.\r\n  if (serviceName === \"twitter\" && !isNaN(serviceData.id)) {\r\n    selector[\"$or\"] = [{},{}];\r\n    selector[\"$or\"][0][serviceIdKey] = serviceData.id;\r\n    selector[\"$or\"][1][serviceIdKey] = parseInt(serviceData.id, 10);\r\n  } else {\r\n    selector[serviceIdKey] = serviceData.id;\r\n  }\r\n\r\n  var user = Meteor.users.findOne(selector);\r\n\r\n  if (user) {\r\n    // We *don't* process options (eg, profile) for update, but we do replace\r\n    // the serviceData (eg, so that we keep an unexpired access token and\r\n    // don't cache old email addresses in serviceData.email).\r\n    // XXX provide an onUpdateUser hook which would let apps update\r\n    //     the profile too\r\n    var stampedToken = Accounts._generateStampedLoginToken();\r\n    var setAttrs = {};\r\n    _.each(serviceData, function(value, key) {\r\n      setAttrs[\"services.\" + serviceName + \".\" + key] = value;\r\n    });\r\n\r\n    // XXX Maybe we should re-use the selector above and notice if the update\r\n    //     touches nothing?\r\n    Meteor.users.update(\r\n      user._id,\r\n      {$set: setAttrs,\r\n       $push: {'services.resume.loginTokens': stampedToken}});\r\n    return {\r\n      token: stampedToken.token,\r\n      id: user._id,\r\n      tokenExpires: Accounts._tokenExpiration(stampedToken.when)\r\n    };\r\n  } else {\r\n    // Create a new user with the service data. Pass other options through to\r\n    // insertUserDoc.\r\n    user = {services: {}};\r\n    user.services[serviceName] = serviceData;\r\n    options.generateLoginToken = true;\r\n    return Accounts.insertUserDoc(options, user);\r\n  }\r\n};\r\n\r\n\r\n///\r\n/// PUBLISHING DATA\r\n///\r\n\r\n// Publish the current user's record to the client.\r\nMeteor.publish(null, function() {\r\n  if (this.userId) {\r\n    return Meteor.users.find(\r\n      {_id: this.userId},\r\n      {fields: {profile: 1, username: 1, emails: 1}});\r\n  } else {\r\n    return null;\r\n  }\r\n}, /*suppress autopublish warning*/{is_auto: true});\r\n\r\n// If autopublish is on, publish these user fields. Login service\r\n// packages (eg accounts-google) add to these by calling\r\n// Accounts.addAutopublishFields Notably, this isn't implemented with\r\n// multiple publishes since DDP only merges only across top-level\r\n// fields, not subfields (such as 'services.facebook.accessToken')\r\nvar autopublishFields = {\r\n  loggedInUser: ['profile', 'username', 'emails'],\r\n  otherUsers: ['profile', 'username']\r\n};\r\n\r\n// Add to the list of fields or subfields to be automatically\r\n// published if autopublish is on. Must be called from top-level\r\n// code (ie, before Meteor.startup hooks run).\r\n//\r\n// @param opts {Object} with:\r\n//   - forLoggedInUser {Array} Array of fields published to the logged-in user\r\n//   - forOtherUsers {Array} Array of fields published to users that aren't logged in\r\nAccounts.addAutopublishFields = function(opts) {\r\n  autopublishFields.loggedInUser.push.apply(\r\n    autopublishFields.loggedInUser, opts.forLoggedInUser);\r\n  autopublishFields.otherUsers.push.apply(\r\n    autopublishFields.otherUsers, opts.forOtherUsers);\r\n};\r\n\r\nif (Package.autopublish) {\r\n  // Use Meteor.startup to give other packages a chance to call\r\n  // addAutopublishFields.\r\n  Meteor.startup(function () {\r\n    // ['profile', 'username'] -> {profile: 1, username: 1}\r\n    var toFieldSelector = function(fields) {\r\n      return _.object(_.map(fields, function(field) {\r\n        return [field, 1];\r\n      }));\r\n    };\r\n\r\n    Meteor.server.publish(null, function () {\r\n      if (this.userId) {\r\n        return Meteor.users.find(\r\n          {_id: this.userId},\r\n          {fields: toFieldSelector(autopublishFields.loggedInUser)});\r\n      } else {\r\n        return null;\r\n      }\r\n    }, /*suppress autopublish warning*/{is_auto: true});\r\n\r\n    // XXX this publish is neither dedup-able nor is it optimized by our special\r\n    // treatment of queries on a specific _id. Therefore this will have O(n^2)\r\n    // run-time performance every time a user document is changed (eg someone\r\n    // logging in). If this is a problem, we can instead write a manual publish\r\n    // function which filters out fields based on 'this.userId'.\r\n    Meteor.server.publish(null, function () {\r\n      var selector;\r\n      if (this.userId)\r\n        selector = {_id: {$ne: this.userId}};\r\n      else\r\n        selector = {};\r\n\r\n      return Meteor.users.find(\r\n        selector,\r\n        {fields: toFieldSelector(autopublishFields.otherUsers)});\r\n    }, /*suppress autopublish warning*/{is_auto: true});\r\n  });\r\n}\r\n\r\n// Publish all login service configuration fields other than secret.\r\nMeteor.publish(\"meteor.loginServiceConfiguration\", function () {\r\n  return ServiceConfiguration.configurations.find({}, {fields: {secret: 0}});\r\n}, {is_auto: true}); // not techincally autopublish, but stops the warning.\r\n\r\n// Allow a one-time configuration for a login service. Modifications\r\n// to this collection are also allowed in insecure mode.\r\nMeteor.methods({\r\n  \"configureLoginService\": function (options) {\r\n    check(options, Match.ObjectIncluding({service: String}));\r\n    // Don't let random users configure a service we haven't added yet (so\r\n    // that when we do later add it, it's set up with their configuration\r\n    // instead of ours).\r\n    // XXX if service configuration is oauth-specific then this code should\r\n    //     be in accounts-oauth; if it's not then the registry should be\r\n    //     in this package\r\n    if (!(Accounts.oauth\r\n          && _.contains(Accounts.oauth.serviceNames(), options.service))) {\r\n      throw new Meteor.Error(403, \"Service unknown\");\r\n    }\r\n    if (ServiceConfiguration.configurations.findOne({service: options.service}))\r\n      throw new Meteor.Error(403, \"Service \" + options.service + \" already configured\");\r\n    ServiceConfiguration.configurations.insert(options);\r\n  }\r\n});\r\n\r\n\r\n///\r\n/// RESTRICTING WRITES TO USER OBJECTS\r\n///\r\n\r\nMeteor.users.allow({\r\n  // clients can modify the profile field of their own document, and\r\n  // nothing else.\r\n  update: function (userId, user, fields, modifier) {\r\n    // make sure it is our record\r\n    if (user._id !== userId)\r\n      return false;\r\n\r\n    // user can only modify the 'profile' field. sets to multiple\r\n    // sub-keys (eg profile.foo and profile.bar) are merged into entry\r\n    // in the fields list.\r\n    if (fields.length !== 1 || fields[0] !== 'profile')\r\n      return false;\r\n\r\n    return true;\r\n  },\r\n  fetch: ['_id'] // we only look at _id.\r\n});\r\n\r\n/// DEFAULT INDEXES ON USERS\r\nMeteor.users._ensureIndex('username', {unique: 1, sparse: 1});\r\nMeteor.users._ensureIndex('emails.address', {unique: 1, sparse: 1});\r\nMeteor.users._ensureIndex('services.resume.loginTokens.token',\r\n                          {unique: 1, sparse: 1});\r\n// For taking care of logoutOtherClients calls that crashed before the tokens\r\n// were deleted.\r\nMeteor.users._ensureIndex('services.resume.haveLoginTokensToDelete',\r\n                          { sparse: 1 });\r\n// For expiring login tokens\r\nMeteor.users._ensureIndex(\"services.resume.loginTokens.when\", { sparse: 1 });\r\n\r\n///\r\n/// CLEAN UP FOR `logoutOtherClients`\r\n///\r\n\r\nvar deleteSavedTokens = function (userId, tokensToDelete) {\r\n  if (tokensToDelete) {\r\n    Meteor.users.update(userId, {\r\n      $unset: {\r\n        \"services.resume.haveLoginTokensToDelete\": 1,\r\n        \"services.resume.loginTokensToDelete\": 1\r\n      },\r\n      $pullAll: {\r\n        \"services.resume.loginTokens\": tokensToDelete\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nMeteor.startup(function () {\r\n  // If we find users who have saved tokens to delete on startup, delete them\r\n  // now. It's possible that the server could have crashed and come back up\r\n  // before new tokens are found in localStorage, but this shouldn't happen very\r\n  // often. We shouldn't put a delay here because that would give a lot of power\r\n  // to an attacker with a stolen login token and the ability to crash the\r\n  // server.\r\n  var users = Meteor.users.find({\r\n    \"services.resume.haveLoginTokensToDelete\": true\r\n  }, {\r\n    \"services.resume.loginTokensToDelete\": 1\r\n  });\r\n  users.forEach(function (user) {\r\n    deleteSavedTokens(user._id, user.services.resume.loginTokensToDelete);\r\n  });\r\n});\r\n\r\n///\r\n/// LOGGING OUT DELETED USERS\r\n///\r\n\r\nvar closeTokensForUser = function (userTokens) {\r\n  Meteor.server._closeAllForTokens(_.map(userTokens, function (token) {\r\n    return token.token;\r\n  }));\r\n};\r\n\r\nMeteor.users.find({}, { fields: { \"services.resume\": 1 }}).observe({\r\n  changed: function (newUser, oldUser) {\r\n    var removedTokens = [];\r\n    if (newUser.services && newUser.services.resume &&\r\n        oldUser.services && oldUser.services.resume) {\r\n      removedTokens = _.difference(oldUser.services.resume.loginTokens || [],\r\n                                   newUser.services.resume.loginTokens || []);\r\n    } else if (oldUser.services && oldUser.services.resume) {\r\n      removedTokens = oldUser.services.resume.loginTokens || [];\r\n    }\r\n    closeTokensForUser(removedTokens);\r\n  },\r\n  removed: function (oldUser) {\r\n    if (oldUser.services && oldUser.services.resume)\r\n      closeTokensForUser(oldUser.services.resume.loginTokens || []);\r\n  }\r\n});\r\n","// XXX These should probably not actually be public?\r\n\r\nAccounts.urls = {};\r\n\r\nAccounts.urls.resetPassword = function (token) {\r\n  return Meteor.absoluteUrl('#/reset-password/' + token);\r\n};\r\n\r\nAccounts.urls.verifyEmail = function (token) {\r\n  return Meteor.absoluteUrl('#/verify-email/' + token);\r\n};\r\n\r\nAccounts.urls.enrollAccount = function (token) {\r\n  return Meteor.absoluteUrl('#/enroll-account/' + token);\r\n};\r\n"]}