{"version":3,"file":"\\packages\\oauth1.js","sources":["oauth1/oauth1_binding.js","oauth1/oauth1_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,mC;AACA,6C;;AAEA,iE;AACA,6B;AACA,E;AACA,0B;AACA,+C;AACA,6C;AACA,uB;AACA,iC;AACA,8B;AACA,gC;AACA,iC;AACA,wC;AACA,wB;AACA,oB;AACA,E;;AAEA,qE;AACA,kB;;AAEA,mC;AACA,+B;AACA,K;;AAEA,sE;AACA,mD;;AAEA,uC;AACA,oB;AACA,6E;;AAEA,yC;AACA,sD;AACA,E;;AAEA,kF;AACA,kB;;AAEA,oE;AACA,wB;AACA,I;AACA,qE;AACA,mE;AACA,mC;AACA,yB;AACA,gD;;AAEA,mC;AACA,kC;AACA,K;;AAEA,gB;AACA,wC;AACA,I;;AAEA,6E;AACA,mD;;AAEA,wC;AACA,qD;AACA,E;;AAEA,wE;AACA,kB;;AAEA,mC;AACA,iC;AACA,K;;AAEA,e;AACA,gB;AACA,G;;AAEA,4D;AACA,E;;AAEA,+D;AACA,iD;AACA,E;;AAEA,gE;AACA,kD;AACA,E;;AAEA,0D;AACA,kB;AACA,mB;AACA,iD;AACA,gD;AACA,wC;AACA,sE;AACA,wB;AACA,c;AACA,E;;AAEA,sG;AACA,kB;AACA,iE;;AAEA,sD;AACA,2B;AACA,sB;;AAEA,uB;AACA,W;AACA,4B;AACA,kC;AACA,c;;AAEA,iE;AACA,wB;AACA,wD;;AAEA,sF;AACA,E;;AAEA,kF;AACA,kB;;AAEA,iE;AACA,iC;AACA,oB;AACA,G;;AAEA,sB;AACA,2B;AACA,6E;;AAEA,yD;AACA,sD;;AAEA,wB;AACA,O;AACA,mC;AACA,qB;AACA,gB;AACA,iC;AACA,O;AACA,iB;AACA,iB;AACA,6F;AACA,6C;AACA,G;AACA,E;;AAEA,0D;AACA,kB;AACA,oD;AACA,4D;AACA,gB;AACA,S;AACA,E;;AAEA,uD;AACA,kF;AACA,E;;AAEA,kE;AACA,kB;AACA,wD;AACA,0E;AACA,uB;AACA,E;;;;;;;;;;;;;;;;;;;ACpKA,uD;AACA,uB;;AAEA,4C;;AAEA,qB;AACA,8D;;AAEA,2F;AACA,gB;AACA,qG;AACA,G;;AAEA,0B;AACA,qD;;AAEA,sC;AACA,6C;;AAEA,gD;AACA,oE;;AAEA,uE;AACA,kC;AACA,+C;AACA,yD;AACA,M;;AAEA,wC;AACA,gC;AACA,iD;AACA,oD;AACA,Y;AACA,oF;AACA,K;;AAEA,6E;AACA,kD;AACA,c;AACA,U;AACA,kE;AACA,iE;AACA,uD;;AAEA,oE;AACA,+D;AACA,2E;AACA,sC;;AAEA,gE;AACA,0C;AACA,kE;;AAEA,kE;AACA,iE;;AAEA,kD;AACA,iE;;AAEA,sC;AACA,iE;;AAEA,+C;AACA,2D;AACA,yC;AACA,6C;AACA,oC;AACA,Q;AACA,K;;AAEA,2D;AACA,wB;AACA,0C;AACA,G;AACA,E","sourcesContent":["var crypto = Npm.require(\"crypto\");\r\nvar querystring = Npm.require(\"querystring\");\r\n\r\n// An OAuth1 wrapper around http calls which helps get tokens and\r\n// takes care of HTTP headers\r\n//\r\n// @param config {Object} \r\n//   - consumerKey (String): oauth consumer key\r\n//   - secret (String): oauth consumer secret\r\n// @param urls {Object}\r\n//   - requestToken (String): url\r\n//   - authorize (String): url\r\n//   - accessToken (String): url\r\n//   - authenticate (String): url\r\nOAuth1Binding = function(config, urls) {\r\n  this._config = config;\r\n  this._urls = urls;\r\n};\r\n\r\nOAuth1Binding.prototype.prepareRequestToken = function(callbackUrl) {\r\n  var self = this;\r\n\r\n  var headers = self._buildHeader({\r\n    oauth_callback: callbackUrl\r\n  });\r\n\r\n  var response = self._call('POST', self._urls.requestToken, headers);\r\n  var tokens = querystring.parse(response.content);\r\n\r\n  if (!tokens.oauth_callback_confirmed)\r\n    throw new Error(\r\n      \"oauth_callback_confirmed false when requesting oauth1 token\", tokens);\r\n\r\n  self.requestToken = tokens.oauth_token;\r\n  self.requestTokenSecret = tokens.oauth_token_secret;\r\n};\r\n\r\nOAuth1Binding.prototype.prepareAccessToken = function(query, requestTokenSecret) {\r\n  var self = this;\r\n\r\n  // support implementations that use request token secrets. This is\r\n  // read by self._call.\r\n  //\r\n  // XXX make it a param to call, not something stashed on self? It's\r\n  // kinda confusing right now, everything except this is passed as\r\n  // arguments, but this is stored.\r\n  if (requestTokenSecret)\r\n    self.accessTokenSecret = requestTokenSecret;\r\n\r\n  var headers = self._buildHeader({\r\n    oauth_token: query.oauth_token\r\n  });\r\n\r\n  var params = {\r\n    oauth_verifier: query.oauth_verifier\r\n  };\r\n\r\n  var response = self._call('POST', self._urls.accessToken, headers, params);\r\n  var tokens = querystring.parse(response.content);\r\n\r\n  self.accessToken = tokens.oauth_token;\r\n  self.accessTokenSecret = tokens.oauth_token_secret;\r\n};\r\n\r\nOAuth1Binding.prototype.call = function(method, url, params, callback) {\r\n  var self = this;\r\n\r\n  var headers = self._buildHeader({\r\n    oauth_token: self.accessToken\r\n  });\r\n\r\n  if(!params) {\r\n    params = {};\r\n  }\r\n\r\n  return self._call(method, url, headers, params, callback);\r\n};\r\n\r\nOAuth1Binding.prototype.get = function(url, params, callback) {\r\n  return this.call('GET', url, params, callback);\r\n};\r\n\r\nOAuth1Binding.prototype.post = function(url, params, callback) {\r\n  return this.call('POST', url, params, callback);\r\n};\r\n\r\nOAuth1Binding.prototype._buildHeader = function(headers) {\r\n  var self = this;\r\n  return _.extend({\r\n    oauth_consumer_key: self._config.consumerKey,\r\n    oauth_nonce: Random.id().replace(/\\W/g, ''),\r\n    oauth_signature_method: 'HMAC-SHA1',\r\n    oauth_timestamp: (new Date().valueOf()/1000).toFixed().toString(),\r\n    oauth_version: '1.0'\r\n  }, headers);\r\n};\r\n\r\nOAuth1Binding.prototype._getSignature = function(method, url, rawHeaders, accessTokenSecret, params) {\r\n  var self = this;\r\n  var headers = self._encodeHeader(_.extend(rawHeaders, params));\r\n\r\n  var parameters = _.map(headers, function(val, key) {\r\n    return key + '=' + val;\r\n  }).sort().join('&');\r\n\r\n  var signatureBase = [\r\n    method,\r\n    self._encodeString(url),\r\n    self._encodeString(parameters)\r\n  ].join('&');\r\n\r\n  var signingKey = self._encodeString(self._config.secret) + '&';\r\n  if (accessTokenSecret)\r\n    signingKey += self._encodeString(accessTokenSecret);\r\n\r\n  return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\r\n};\r\n\r\nOAuth1Binding.prototype._call = function(method, url, headers, params, callback) {\r\n  var self = this;\r\n\r\n  // all URLs to be functions to support parameters/customization\r\n  if(typeof url === \"function\") {\r\n    url = url(self);\r\n  }\r\n\r\n  // Get the signature\r\n  headers.oauth_signature =\r\n    self._getSignature(method, url, headers, self.accessTokenSecret, params);\r\n\r\n  // Make a authorization string according to oauth1 spec\r\n  var authString = self._getAuthHeaderString(headers);\r\n\r\n  // Make signed request\r\n  try {\r\n    return HTTP.call(method, url, {\r\n      params: params,\r\n      headers: {\r\n        Authorization: authString\r\n      }\r\n    }, callback);\r\n  } catch (err) {\r\n    throw _.extend(new Error(\"Failed to send OAuth1 request to \" + url + \". \" + err.message),\r\n                   {response: err.response});\r\n  }\r\n};\r\n\r\nOAuth1Binding.prototype._encodeHeader = function(header) {\r\n  var self = this;\r\n  return _.reduce(header, function(memo, val, key) {\r\n    memo[self._encodeString(key)] = self._encodeString(val);\r\n    return memo;\r\n  }, {});\r\n};\r\n\r\nOAuth1Binding.prototype._encodeString = function(str) {\r\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\r\n};\r\n\r\nOAuth1Binding.prototype._getAuthHeaderString = function(headers) {\r\n  var self = this;\r\n  return 'OAuth ' +  _.map(headers, function(val, key) {\r\n    return self._encodeString(key) + '=\"' + self._encodeString(val) + '\"';\r\n  }).sort().join(', ');\r\n};\r\n","// A place to store request tokens pending verification\r\nvar requestTokens = {};\r\n\r\nOAuth1Test = {requestTokens: requestTokens};\r\n\r\n// connect middleware\r\nOauth._requestHandlers['1'] = function (service, query, res) {\r\n\r\n  var config = ServiceConfiguration.configurations.findOne({service: service.serviceName});\r\n  if (!config) {\r\n    throw new ServiceConfiguration.ConfigError(\"Service \" + service.serviceName + \" not configured\");\r\n  }\r\n\r\n  var urls = service.urls;\r\n  var oauthBinding = new OAuth1Binding(config, urls);\r\n\r\n  if (query.requestTokenAndRedirect) {\r\n    // step 1 - get and store a request token\r\n\r\n    // Get a request token to start auth process\r\n    oauthBinding.prepareRequestToken(query.requestTokenAndRedirect);\r\n\r\n    // Keep track of request token so we can verify it on the next step\r\n    requestTokens[query.state] = {\r\n      requestToken: oauthBinding.requestToken, \r\n      requestTokenSecret: oauthBinding.requestTokenSecret\r\n    };\r\n\r\n    // support for scope/name parameters\r\n    var redirectUrl = undefined;\r\n    if(typeof urls.authenticate === \"function\") {\r\n      redirectUrl = urls.authenticate(oauthBinding);\r\n    } else {\r\n      redirectUrl = urls.authenticate + '?oauth_token=' + oauthBinding.requestToken;\r\n    }\r\n\r\n    // redirect to provider login, which will redirect back to \"step 2\" below\r\n    res.writeHead(302, {'Location': redirectUrl});\r\n    res.end();\r\n  } else {\r\n    // step 2, redirected from provider login - complete the login\r\n    // process: if the user authorized permissions, get an access\r\n    // token and access token secret and log in as user\r\n\r\n    // Get the user's request token so we can verify it and clear it\r\n    var requestToken = requestTokens[query.state].requestToken;\r\n    var requestTokenSecret = requestTokens[query.state].requestTokenSecret;\r\n    delete requestTokens[query.state];\r\n\r\n    // Verify user authorized access and the oauth_token matches\r\n    // the requestToken from previous step\r\n    if (query.oauth_token && query.oauth_token === requestToken) {\r\n\r\n      // Prepare the login results before returning.  This way the\r\n      // subsequent call to the `login` method will be immediate.\r\n\r\n      // Get the access token for signing requests\r\n      oauthBinding.prepareAccessToken(query, requestTokenSecret);\r\n\r\n      // Run service-specific handler.\r\n      var oauthResult = service.handleOauthRequest(oauthBinding);\r\n\r\n      // Add the login result to the result map\r\n      Oauth._loginResultForCredentialToken[query.state] = {\r\n        serviceName: service.serviceName,\r\n        serviceData: oauthResult.serviceData,\r\n        options: oauthResult.options\r\n      };\r\n    }\r\n\r\n    // Either close the window, redirect, or render nothing\r\n    // if all else fails\r\n    Oauth._renderOauthResults(res, query);\r\n  }\r\n};\r\n"]}