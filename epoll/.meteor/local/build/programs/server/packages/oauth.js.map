{"version":3,"file":"\\packages\\oauth.js","sources":["oauth/oauth_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,kC;;AAEA,W;AACA,e;;AAEA,2C;;AAEA,4B;;AAEA,+D;AACA,sE;AACA,iB;AACA,E;AACA,4B;;;AAGA,sE;AACA,sE;AACA,mE;AACA,c;AACA,E;AACA,iD;AACA,iD;AACA,4D;AACA,2D;AACA,uF;AACA,yE;AACA,uB;AACA,yE;AACA,8C;AACA,wD;AACA,E;AACA,4E;AACA,+B;AACA,yE;;AAEA,8B;AACA,sB;AACA,qB;AACA,e;AACA,0C;AACA,I;AACA,E;;AAEA,oB;AACA,+C;AACA,kC;AACA,E;;;AAGA,mE;AACA,6D;AACA,mE;AACA,qE;AACA,E;AACA,qE;AACA,4C;AACA,E;AACA,+C;AACA,E;AACA,0C;;AAEA,iD;AACA,sE;AACA,C;;AAEA,sD;AACA,qE;AACA,+D;AACA,gB;AACA,C;;AAEA,yC;AACA,qD;AACA,gF;AACA,mD;AACA,qB;AACA,+B;AACA,W;AACA,G;;AAEA,wC;AACA,mE;AACA,e;AACA,O;AACA,4C;AACA,uB;AACA,uD;AACA,a;AACA,a;AACA,K;;AAEA,kD;;AAEA,wE;AACA,iB;AACA,iE;;AAEA,iC;AACA,kC;;AAEA,0D;AACA,iB;AACA,qE;AACA,qC;AACA,iB;AACA,oE;AACA,+D;AACA,M;AACA,oE;AACA,sE;AACA,iE;AACA,iD;AACA,gD;AACA,kE;;AAEA,+D;AACA,iE;AACA,4B;AACA,gD;AACA,kE;AACA,iD;AACA,oE;AACA,M;AACA,8D;AACA,+D;AACA,4C;AACA,oB;AACA,G;AACA,E;;AAEA,kC;;AAEA,sD;AACA,E;AACA,mE;AACA,gB;AACA,uC;AACA,sD;AACA,4D;AACA,sC;;AAEA,yD;AACA,iB;AACA,gC;AACA,gB;;AAEA,8B;AACA,iC;AACA,qB;AACA,E;;AAEA,6B;AACA,8C;AACA,6E;AACA,yE;AACA,I;AACA,E;;AAEA,mD;AACA,kD;AACA,gE;AACA,4B;AACA,yE;AACA,oB;AACA,8B;AACA,qD;AACA,c;AACA,U;AACA,sD;AACA,yB;AACA,G;AACA,E;;AAEA,gC;AACA,oD;AACA,e;AACA,oE;AACA,4B;AACA,E","sourcesContent":["var Fiber = Npm.require('fibers');\r\n\r\nOauth = {};\r\nOauthTest = {};\r\n\r\nRoutePolicy.declare('/_oauth/', 'network');\r\n\r\nvar registeredServices = {};\r\n\r\n// Internal: Maps from service version to handler function. The\r\n// 'oauth1' and 'oauth2' packages manipulate this directly to register\r\n// for callbacks.\r\n//\r\nOauth._requestHandlers = {};\r\n\r\n\r\n// Register a handler for an OAuth service. The handler will be called\r\n// when we get an incoming http request on /_oauth/{serviceName}. This\r\n// handler should use that information to fetch data about the user\r\n// logging in.\r\n//\r\n// @param name {String} e.g. \"google\", \"facebook\"\r\n// @param version {Number} OAuth version (1 or 2)\r\n// @param urls   For OAuth1 only, specify the service's urls\r\n// @param handleOauthRequest {Function(oauthBinding|query)}\r\n//   - (For OAuth1 only) oauthBinding {OAuth1Binding} bound to the appropriate provider\r\n//   - (For OAuth2 only) query {Object} parameters passed in query string\r\n//   - return value is:\r\n//     - {serviceData:, (optional options:)} where serviceData should end\r\n//       up in the user's services[name] field\r\n//     - `null` if the user declined to give permissions\r\n//\r\nOauth.registerService = function (name, version, urls, handleOauthRequest) {\r\n  if (registeredServices[name])\r\n    throw new Error(\"Already registered the \" + name + \" OAuth service\");\r\n\r\n  registeredServices[name] = {\r\n    serviceName: name,\r\n    version: version,\r\n    urls: urls,\r\n    handleOauthRequest: handleOauthRequest\r\n  };\r\n};\r\n\r\n// For test cleanup.\r\nOauthTest.unregisterService = function (name) {\r\n  delete registeredServices[name];\r\n};\r\n\r\n\r\n// When we get an incoming OAuth http request we complete the oauth\r\n// handshake, account and token setup before responding.  The\r\n// results are stored in this map which is then read when the login\r\n// method is called. Maps credentialToken --> return value of `login`\r\n//\r\n// NB: the oauth1 and oauth2 packages manipulate this directly. might\r\n// be nice for them to have a setter instead\r\n//\r\n// XXX we should periodically clear old entries\r\n//\r\nOauth._loginResultForCredentialToken = {};\r\n\r\nOauth.hasCredential = function(credentialToken) {\r\n  return _.has(Oauth._loginResultForCredentialToken, credentialToken);\r\n}\r\n\r\nOauth.retrieveCredential = function(credentialToken) {\r\n  var result = Oauth._loginResultForCredentialToken[credentialToken];\r\n  delete Oauth._loginResultForCredentialToken[credentialToken];\r\n  return result;\r\n}\r\n\r\n// Listen to incoming OAuth http requests\r\nWebApp.connectHandlers.use(function(req, res, next) {\r\n  // Need to create a Fiber since we're using synchronous http calls and nothing\r\n  // else is wrapping this in a fiber automatically\r\n  Fiber(function () {\r\n    middleware(req, res, next);\r\n  }).run();\r\n});\r\n\r\nmiddleware = function (req, res, next) {\r\n  // Make sure to catch any exceptions because otherwise we'd crash\r\n  // the runner\r\n  try {\r\n    var serviceName = oauthServiceName(req);\r\n    if (!serviceName) {\r\n      // not an oauth request. pass to next middleware.\r\n      next();\r\n      return;\r\n    }\r\n\r\n    var service = registeredServices[serviceName];\r\n\r\n    // Skip everything if there's no service set by the oauth middleware\r\n    if (!service)\r\n      throw new Error(\"Unexpected OAuth service \" + serviceName);\r\n\r\n    // Make sure we're configured\r\n    ensureConfigured(serviceName);\r\n\r\n    var handler = Oauth._requestHandlers[service.version];\r\n    if (!handler)\r\n      throw new Error(\"Unexpected OAuth version \" + service.version);\r\n    handler(service, req.query, res);\r\n  } catch (err) {\r\n    // if we got thrown an error, save it off, it will get passed to\r\n    // the approporiate login call (if any) and reported there.\r\n    //\r\n    // The other option would be to display it in the popup tab that\r\n    // is still open at this point, ignoring the 'close' or 'redirect'\r\n    // we were passed. But then the developer wouldn't be able to\r\n    // style the error or react to it in any way.\r\n    if (req.query.state && err instanceof Error)\r\n      Oauth._loginResultForCredentialToken[req.query.state] = err;\r\n\r\n    // XXX the following is actually wrong. if someone wants to\r\n    // redirect rather than close once we are done with the OAuth\r\n    // flow, as supported by\r\n    // Oauth_renderOauthResults, this will still\r\n    // close the popup instead. Once we fully support the redirect\r\n    // flow (by supporting that in places such as\r\n    // packages/facebook/facebook_client.js) we should revisit this.\r\n    //\r\n    // close the popup. because nobody likes them just hanging\r\n    // there.  when someone sees this multiple times they might\r\n    // think to check server logs (we hope?)\r\n    closePopup(res);\r\n  }\r\n};\r\n\r\nOauthTest.middleware = middleware;\r\n\r\n// Handle /_oauth/* paths and extract the service name\r\n//\r\n// @returns {String|null} e.g. \"facebook\", or null if this isn't an\r\n// oauth request\r\nvar oauthServiceName = function (req) {\r\n  // req.url will be \"/_oauth/<service name>?<action>\"\r\n  var barePath = req.url.substring(0, req.url.indexOf('?'));\r\n  var splitPath = barePath.split('/');\r\n\r\n  // Any non-oauth request will continue down the default\r\n  // middlewares.\r\n  if (splitPath[1] !== '_oauth')\r\n    return null;\r\n\r\n  // Find service based on url\r\n  var serviceName = splitPath[2];\r\n  return serviceName;\r\n};\r\n\r\n// Make sure we're configured\r\nvar ensureConfigured = function(serviceName) {\r\n  if (!ServiceConfiguration.configurations.findOne({service: serviceName})) {\r\n    throw new ServiceConfiguration.ConfigError(\"Service not configured\");\r\n  };\r\n};\r\n\r\n// Internal: used by the oauth1 and oauth2 packages\r\nOauth._renderOauthResults = function(res, query) {\r\n  // We support ?close and ?redirect=URL. Any other query should\r\n  // just serve a blank page\r\n  if ('close' in query) { // check with 'in' because we don't set a value\r\n    closePopup(res);\r\n  } else if (query.redirect) {\r\n    res.writeHead(302, {'Location': query.redirect});\r\n    res.end();\r\n  } else {\r\n    res.writeHead(200, {'Content-Type': 'text/html'});\r\n    res.end('', 'utf-8');\r\n  }\r\n};\r\n\r\nvar closePopup = function(res) {\r\n  res.writeHead(200, {'Content-Type': 'text/html'});\r\n  var content =\r\n        '<html><head><script>window.close()</script></head></html>';\r\n  res.end(content, 'utf-8');\r\n};\r\n\r\n"]}